######################################
#    LIBRARIES
######################################
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
library(dplyr)
library(Seurat)
library(cowplot)
library(ggplot2)
library(readr)
library(tidyverse)
library(hdf5r)
library(patchwork)
#
# DATA REQUIREMENTS:
#
#'*host directory* is the directory containing the VisiumHD outs folder
# The host directory must contain:
# folder tree: outs/binned_outputs/square_008um/spatial folder tree
# files:
# *.csv files with selected area barcodes exported from Loupe Browser
# outs/binned_outputs/square_008um/filtered_feature_bc_matrix.h5
# outs/binned_outputs/square_008um/spatial/scalefactors_json.json
# outs/binned_outputs/square_008um/spatial/tissue_positions.parquet
# outs/binned_outputs/square_008um/spatial/tissue_hires_image.png
# outs/binned_outputs/square_008um/spatial/tissue_lowres_image.png
#
# The latter 2 files may need to be copied from the outs/spatial folder
# in the original VisiumHD results
#
# FUNCTIONS:
#
#'*LoadHD8um(results.dir, heGenes=NULL)* - creates Seurat object from the *.h5 file using the high resolution image
#'*results.dir* is the host directory path, e.g., "D:/VisiumHD/experiment1" when the outs folder is "D:/VisiumHD/experiment1/outs"
#'*heGenes* is a list of high expression genes to be used for data calibration, quality control, etc. Deafault value is NULL.
# For instance, heGenes=c("Col1a1","Col1a2") is very useful for mouse samples containing connective tissue. This setting will generate
# two features "RC_Col1a1" and "RC_Col1a2" in addition to "nCount_Spatial.008um" in the object metadata, which are relative counts (RC)
# of Col1a1 and Col1a2 (%UMI*100). They can be used for visualizing the connective tissue with the GeneMap function (see below),
# eliminating fibroblasts and other cells producing a lot of collagen I from the analysis based on subsetting with 
# RC_Col1a1<X&RC_Col1a2<2 threshold, or analyzing just such cells (e.g., we often use subsetting with RC_Cola1+RC_Col1a2>500 to analyze 
# just mature osteoblasts in bone samples, which works very well). We also often include endogenous control genes into heGenes for
# quality control.


#'*CropHD(object,barcodes,padding=0.05, xoffset=8, yoffset=8)* - crops the Seurat object (including the embedded image) to the selected area
#'*Ignore the "Not validating..." warnings generated by this function*, which are related to Seurat's "unfamiliarity" with the need for cropping
# high-resolution images to improve visualization, reduce object size, and increase processing speed. The same warnings will continue appearing
# each time cropped objects are used. They can be safely ignored.
#'*barcodes* parameter value should be the name of the *.csv file without the .csv extension that contains the selected area barcodes,
# e.g., barcodes="D:/VisiumHD/experiment1/Top" will read the barcodes from the D:/VisiumHD/experiment1/Top.csv file. This parameter must be defined 
#'*xoffset and yoffset* parameters enable fine-tuning the alignment of the VisiumHD bins with the cropped high-resolution image, if needed.
#
#'*GeneMap(object,map.features="nCount_Spatial.008um",map.limits=c(0,10000),pt.size=1,map.breaks=c(0,2500,5000,7500,10000)*
# Overlays tissue image with color coded intensity of the feature defined by the map.features parameter
#'*map.features* values can be "nCount_Spatial.008um", one of "RC_  " features generated by the heGenes= parameter (see above), or any of the genes
# in the data layer of the object after object normalization. If  heGenes=c("Col1a1","Col1a2") is defined as in the example above,
# GeneMap(object,map.features="RC_Col1a1") will generate a map for relative counts (%UMI*100) of Col1a1 in each spatial bin,
# GeneMap(object,map.features="RC_Col1a2") will generate a map for relative counts (%UMI*100) of Col1a2 in each spatial bin,
# GeneMap(object,map.features="nCount_Spatial.008um") will generate a map of total UMI counts (absolute value) in each spatial bin,
# regardless of whether and how the object is normalized.  
# While multiple features can be defined, this function has been designed for visualizing a single feature.
#
######################################
#    Load HiRes VisiumHD Object Function
######################################
LoadHD8um <- function(results.dir, heGenes=NULL){
  outs.dir <- str_c(results.dir,"/outs")
  HDimage.dir <- str_c(outs.dir,"/binned_outputs/square_008um/spatial")
  object <- Load10X_Spatial(data.dir = outs.dir, bin.size = c(8))
  hires <- Read10X_Image(HDimage.dir, image.name = "tissue_hires_image.png")
  #Replacing LowREs image with HiRes one
  lowres <- object@images$slice1.008um
  hires@scale.factors$lowres = hires@scale.factors$hires
  hires@assay = lowres@assay
  hires@key = lowres@key
  object@images$slice1.008um = hires
  if (!is.null(heGenes)){
    meta.counts <- FetchData(object, vars=heGenes, layer="counts")
    RCgenes<-paste0("RC_",heGenes)
    for (gene in heGenes) {
      RCgene=paste0("RC_",gene)
      object@meta.data[[RCgene]] <- meta.counts[[gene]]*10000/object@meta.data[["nCount_Spatial.008um"]]
    }
  }
  return(object)
}
#
######################################
#    Crop VisiumHD Object Function
#     Use xoffset and yoffset
#   for more precise image alignment
######################################
CropHD <- function(object,barcodes=NULL,padding=0.05,xoffset=8,yoffset=8){
  if (is.null(barcodes)) {stop("The name of a *.csv file containing Barcode column that defines the cropped area must be specified using barcodes =")}
  file.name<-str_c(barcodes,".csv")
  SbSt <- read.csv(file.name)
  SbSt_barcodes <- SbSt$Barcode
  object_SbSt <- subset(object, cells=SbSt_barcodes)
  #calculating coordinates for image cropping
  sf <- object@images$slice1.008um@scale.factors$hires
  xmin <- sf*object_SbSt@images$slice1.008um@boundaries$centroids@bbox[[1,1]]
  xmax <- sf*object_SbSt@images$slice1.008um@boundaries$centroids@bbox[[1,2]]
  ymin <- sf*object_SbSt@images$slice1.008um@boundaries$centroids@bbox[[2,1]]
  ymax <- sf*object_SbSt@images$slice1.008um@boundaries$centroids@bbox[[2,2]]
  xminp <- xmin-padding*(xmax-xmin)
  xmaxp <- xmax+padding*(xmax-xmin)
  yminp <- ymin-padding*(ymax-ymin)
  ymaxp <- ymax+padding*(ymax-ymin)
  sf <- object@images$slice1.008um@scale.factors$lowres
  object_Crop <- object_SbSt
  object_Crop@images$slice1.008um@image <- object@images$slice1.008um@image[c(xminp:xmaxp), c(yminp:ymaxp), ]
  object_Crop@images$slice1.008um@boundaries$centroids <- Crop(object_SbSt@images$slice1.008um@boundaries$centroids, y = c(xmin/sf, xmax/sf), x = c(ymin/sf,ymax/sf), coords = "plot")
  # Correct for centroid coordinate offset
  temp <- object_Crop@images$slice1.008um@boundaries$centroids@coords
  for (rownum in c(1:nrow(temp))) {
    for (colnum in c(1:ncol(temp))) {
      if (colnum == 1) {
        temp[rownum, colnum] <- temp[rownum, colnum] - (xminp/sf) + yoffset
      } else if (colnum == 2) {
        temp[rownum, colnum] <- temp[rownum, colnum] - (yminp/sf) + xoffset 
      }
    }
  }
  object_Crop@images$slice1.008um@boundaries$centroids@coords <- temp
  object_Crop@images$slice1.008um@boundaries$centroids@bbox[[1,1]] <- 0
  object_Crop@images$slice1.008um@boundaries$centroids@bbox[[1,2]] <- xmax/sf
  object_Crop@images$slice1.008um@boundaries$centroids@bbox[[2,1]] <- 0
  object_Crop@images$slice1.008um@boundaries$centroids@bbox[[2,2]] <- ymax/sf
  names(object_Crop@images) <- barcodes
  Key(object_Crop[[barcodes]]) <- str_c(barcodes,"_")
  return(object_Crop)
}
#
######################################
#    GeneExpressionMap
######################################
#
GeneMap <- function(object,map.features="nCount_Spatial.008um",map.limits=c(0,10000),pt.size=1,map.breaks=c(0,2500,5000,7500,10000),
                    map.colors= c("#00008b","#00ff8b","yellow","#cf2222"),image.crop=FALSE,colorbar.position="bottom",legend.size=1){
  SpatialFeaturePlot(object, features = map.features, pt.size.factor = pt.size,crop = image.crop)+
    ggplot2::scale_fill_gradientn(limits=map.limits,breaks=map.breaks,colors=map.colors)+
    theme(legend.position = colorbar.position, legend.key.width = unit(1*legend.size,"cm"),
          legend.key.height = unit(0.6*legend.size,"cm"),
          legend.title = element_text(size=14*legend.size),
          legend.text = element_text(size=12*legend.size))
}
#